/**
 * The DOMs are assigned to a JS-created 'div'
 * to avoid accessing a null object when the original HTML DOMs
 * are not yet accessible through document 'DOMContentLoaded' event.
 */
export let cli_DOM = document.createElement('div'),
  dynamicLine_DOM = document.createElement('div'),
  dynamicPrompt_DOM = document.createElement('div'),
  dynamicCommand_DOM = document.createElement('div');

// HTML DOMs availability condition for function access in this file
let isDOMContentLoaded = false;

/** HTML DOMs Access Initialization */
document.addEventListener('DOMContentLoaded', () => {
  isDOMContentLoaded = true;
  cli_DOM = document.getElementById('cli');
  dynamicLine_DOM = document.getElementById('dynamic');
  dynamicPrompt_DOM = document.querySelector('#dynamic .prompt');
  dynamicCommand_DOM = document.querySelector('#dynamic .command');
});

/**
 * Create 'div' contains dynamic line string above it.
 * @param {string} stringifiedPath
 */
export function createStaticLine(stringifiedPath) {
  if (isDOMContentLoaded) {
    // create static line
    const staticLine_DOM = document.createElement('div');
    staticLine_DOM.classList.add('static');
    staticLine_DOM.classList.add('line');
    staticLine_DOM.contentEditable = 'false';

    // create static prompt
    const staticPrompt_DOM = document.createElement('div');
    staticPrompt_DOM.classList.add('prompt');
    staticPrompt_DOM.textContent = stringifiedPath;

    // create static command
    const staticCommand_DOM = document.createElement('div');
    staticCommand_DOM.classList.add('command');
    staticCommand_DOM.textContent = dynamicCommand_DOM.textContent;

    // put static line above the dynamic line
    staticLine_DOM.appendChild(staticPrompt_DOM);
    staticLine_DOM.appendChild(staticCommand_DOM);
    cli_DOM.insertBefore(staticLine_DOM, dynamicLine_DOM);
  }
}

/**
 * Color code for generated static line by 'displayOutput'.
 */
export class DisplayColorCode {
  #r = 0;
  #g = 0;
  #b = 0;

  // limit between 0-255 and round up
  #clamp(value) {
    if (typeof value !== 'number' || isNaN(value)) {
      return 0;
    }
    return Math.max(0, Math.min(255, Math.round(value)));
  }

  /**
   * @param {number} r - red
   * @param {number} g - green
   * @param {number} b - blue
   */
  constructor(r, g, b) {
    this.#r = this.#clamp(r);
    this.#g = this.#clamp(g);
    this.#b = this.#clamp(b);
  }

  /**
   * The 'div' generated by 'displayOutput'
   * uses this for its 'style.color'.
   * @returns {string}
   */
  stringify() {
    return `rgb(${this.#r},${this.#g},${this.#b})`;
  }
}

// color code presets
export const DISPLAY_COLOR_NORMAL = new DisplayColorCode(255, 255, 255);
export const DISPLAY_COLOR_ERROR = new DisplayColorCode(255, 0, 0);
export const DISPLAY_COLOR_WARNING = new DisplayColorCode(255, 255, 0);

/**
 * Generate a static line above the dynamic line.
 * Intended for file content or command messages.
 * @param {string} content - expected as descriptive text
 * @param {DisplayColorCode} displayColorCode
 */
export function displayOutput(content, displayColorCode = DISPLAY_COLOR_NORMAL) {
  if (isDOMContentLoaded) {

    // create static line
    const staticContent_DOM = document.createElement('div');
    staticContent_DOM.classList.add('static');
    staticContent_DOM.classList.add('line');
    staticContent_DOM.contentEditable = 'false';
    staticContent_DOM.textContent = content;

    // coloring the line
    if (displayColorCode instanceof DisplayColorCode) {
      staticContent_DOM.style.color = displayColorCode.stringify();
    }

    // put static line above the dynamic line
    cli_DOM.insertBefore(staticContent_DOM, dynamicLine_DOM);
  }
}

/**
 * Get text content from dynamic command.
 * @returns {string}
 */
export function getCommandStrings() {
  return dynamicCommand_DOM.textContent.trim().split(/\s+/);
}
